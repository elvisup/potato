// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: face_reply.proto

#ifndef PROTOBUF_INCLUDED_face_5freply_2eproto
#define PROTOBUF_INCLUDED_face_5freply_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "face_attribute.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_face_5freply_2eproto 

namespace protobuf_face_5freply_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_face_5freply_2eproto
namespace sputnik {
namespace pb {
class FaceAttributeReply;
class FaceAttributeReplyDefaultTypeInternal;
extern FaceAttributeReplyDefaultTypeInternal _FaceAttributeReply_default_instance_;
class FaceFeatureVersion;
class FaceFeatureVersionDefaultTypeInternal;
extern FaceFeatureVersionDefaultTypeInternal _FaceFeatureVersion_default_instance_;
class FaceRecognitionReply;
class FaceRecognitionReplyDefaultTypeInternal;
extern FaceRecognitionReplyDefaultTypeInternal _FaceRecognitionReply_default_instance_;
class FaceReply;
class FaceReplyDefaultTypeInternal;
extern FaceReplyDefaultTypeInternal _FaceReply_default_instance_;
class FaceTokenReply;
class FaceTokenReplyDefaultTypeInternal;
extern FaceTokenReplyDefaultTypeInternal _FaceTokenReply_default_instance_;
class TokenScore;
class TokenScoreDefaultTypeInternal;
extern TokenScoreDefaultTypeInternal _TokenScore_default_instance_;
}  // namespace pb
}  // namespace sputnik
namespace google {
namespace protobuf {
template<> ::sputnik::pb::FaceAttributeReply* Arena::CreateMaybeMessage<::sputnik::pb::FaceAttributeReply>(Arena*);
template<> ::sputnik::pb::FaceFeatureVersion* Arena::CreateMaybeMessage<::sputnik::pb::FaceFeatureVersion>(Arena*);
template<> ::sputnik::pb::FaceRecognitionReply* Arena::CreateMaybeMessage<::sputnik::pb::FaceRecognitionReply>(Arena*);
template<> ::sputnik::pb::FaceReply* Arena::CreateMaybeMessage<::sputnik::pb::FaceReply>(Arena*);
template<> ::sputnik::pb::FaceTokenReply* Arena::CreateMaybeMessage<::sputnik::pb::FaceTokenReply>(Arena*);
template<> ::sputnik::pb::TokenScore* Arena::CreateMaybeMessage<::sputnik::pb::TokenScore>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sputnik {
namespace pb {

enum FaceAttributeReplyStatus {
  ARS_UNKNOWN = 0,
  ARS_SUCCESS = 1,
  ARS_NO_FACE = 2,
  ARS_NO_MODEL = 3,
  FaceAttributeReplyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FaceAttributeReplyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FaceAttributeReplyStatus_IsValid(int value);
const FaceAttributeReplyStatus FaceAttributeReplyStatus_MIN = ARS_UNKNOWN;
const FaceAttributeReplyStatus FaceAttributeReplyStatus_MAX = ARS_NO_MODEL;
const int FaceAttributeReplyStatus_ARRAYSIZE = FaceAttributeReplyStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* FaceAttributeReplyStatus_descriptor();
inline const ::std::string& FaceAttributeReplyStatus_Name(FaceAttributeReplyStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    FaceAttributeReplyStatus_descriptor(), value);
}
inline bool FaceAttributeReplyStatus_Parse(
    const ::std::string& name, FaceAttributeReplyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaceAttributeReplyStatus>(
    FaceAttributeReplyStatus_descriptor(), name, value);
}
enum FaceQuality {
  FQ_UNKNOWN = 0,
  FQ_GOOD = 1,
  FQ_TOO_SMALL = 2,
  FQ_TOO_LARGE_PITCH = 3,
  FQ_TOO_LARGE_YAW = 4,
  FQ_TOO_LARGE_ROLL = 5,
  FQ_TOO_BLUR = 6,
  FQ_NO_FACE = 7,
  FaceQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FaceQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FaceQuality_IsValid(int value);
const FaceQuality FaceQuality_MIN = FQ_UNKNOWN;
const FaceQuality FaceQuality_MAX = FQ_NO_FACE;
const int FaceQuality_ARRAYSIZE = FaceQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* FaceQuality_descriptor();
inline const ::std::string& FaceQuality_Name(FaceQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    FaceQuality_descriptor(), value);
}
inline bool FaceQuality_Parse(
    const ::std::string& name, FaceQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaceQuality>(
    FaceQuality_descriptor(), name, value);
}
enum FaceTokenReplyStatus {
  FTRS_UNKNOWN = 0,
  FTRS_SUCCESS = 1,
  FTRS_NO_FACE = 2,
  FTRS_MULTIPLE_FACES = 3,
  FTRS_LOW_QUALITY_FACE = 4,
  FTRS_TIMEOUT = 5,
  FTRS_NO_MODEL = 6,
  FaceTokenReplyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FaceTokenReplyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FaceTokenReplyStatus_IsValid(int value);
const FaceTokenReplyStatus FaceTokenReplyStatus_MIN = FTRS_UNKNOWN;
const FaceTokenReplyStatus FaceTokenReplyStatus_MAX = FTRS_NO_MODEL;
const int FaceTokenReplyStatus_ARRAYSIZE = FaceTokenReplyStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* FaceTokenReplyStatus_descriptor();
inline const ::std::string& FaceTokenReplyStatus_Name(FaceTokenReplyStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    FaceTokenReplyStatus_descriptor(), value);
}
inline bool FaceTokenReplyStatus_Parse(
    const ::std::string& name, FaceTokenReplyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaceTokenReplyStatus>(
    FaceTokenReplyStatus_descriptor(), name, value);
}
// ===================================================================

class TokenScore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.TokenScore) */ {
 public:
  TokenScore();
  virtual ~TokenScore();

  TokenScore(const TokenScore& from);

  inline TokenScore& operator=(const TokenScore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TokenScore(TokenScore&& from) noexcept
    : TokenScore() {
    *this = ::std::move(from);
  }

  inline TokenScore& operator=(TokenScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TokenScore* internal_default_instance() {
    return reinterpret_cast<const TokenScore*>(
               &_TokenScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TokenScore* other);
  friend void swap(TokenScore& a, TokenScore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TokenScore* New() const final {
    return CreateMaybeMessage<TokenScore>(NULL);
  }

  TokenScore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TokenScore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TokenScore& from);
  void MergeFrom(const TokenScore& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenScore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double score = 2;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  double score() const;
  void set_score(double value);

  // int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.TokenScore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double score_;
  ::google::protobuf::int32 token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5freply_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceAttributeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceAttributeReply) */ {
 public:
  FaceAttributeReply();
  virtual ~FaceAttributeReply();

  FaceAttributeReply(const FaceAttributeReply& from);

  inline FaceAttributeReply& operator=(const FaceAttributeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceAttributeReply(FaceAttributeReply&& from) noexcept
    : FaceAttributeReply() {
    *this = ::std::move(from);
  }

  inline FaceAttributeReply& operator=(FaceAttributeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceAttributeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceAttributeReply* internal_default_instance() {
    return reinterpret_cast<const FaceAttributeReply*>(
               &_FaceAttributeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FaceAttributeReply* other);
  friend void swap(FaceAttributeReply& a, FaceAttributeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceAttributeReply* New() const final {
    return CreateMaybeMessage<FaceAttributeReply>(NULL);
  }

  FaceAttributeReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceAttributeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceAttributeReply& from);
  void MergeFrom(const FaceAttributeReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceAttributeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sputnik.pb.FaceAttribute attribute = 2;
  bool has_attribute() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 2;
  private:
  const ::sputnik::pb::FaceAttribute& _internal_attribute() const;
  public:
  const ::sputnik::pb::FaceAttribute& attribute() const;
  ::sputnik::pb::FaceAttribute* release_attribute();
  ::sputnik::pb::FaceAttribute* mutable_attribute();
  void set_allocated_attribute(::sputnik::pb::FaceAttribute* attribute);

  // .sputnik.pb.FaceAttributeReplyStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::sputnik::pb::FaceAttributeReplyStatus status() const;
  void set_status(::sputnik::pb::FaceAttributeReplyStatus value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceAttributeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sputnik::pb::FaceAttribute* attribute_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5freply_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceFeatureVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceFeatureVersion) */ {
 public:
  FaceFeatureVersion();
  virtual ~FaceFeatureVersion();

  FaceFeatureVersion(const FaceFeatureVersion& from);

  inline FaceFeatureVersion& operator=(const FaceFeatureVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceFeatureVersion(FaceFeatureVersion&& from) noexcept
    : FaceFeatureVersion() {
    *this = ::std::move(from);
  }

  inline FaceFeatureVersion& operator=(FaceFeatureVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceFeatureVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceFeatureVersion* internal_default_instance() {
    return reinterpret_cast<const FaceFeatureVersion*>(
               &_FaceFeatureVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FaceFeatureVersion* other);
  friend void swap(FaceFeatureVersion& a, FaceFeatureVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceFeatureVersion* New() const final {
    return CreateMaybeMessage<FaceFeatureVersion>(NULL);
  }

  FaceFeatureVersion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceFeatureVersion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceFeatureVersion& from);
  void MergeFrom(const FaceFeatureVersion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceFeatureVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string model_version = 1;
  void clear_model_version();
  static const int kModelVersionFieldNumber = 1;
  const ::std::string& model_version() const;
  void set_model_version(const ::std::string& value);
  #if LANG_CXX11
  void set_model_version(::std::string&& value);
  #endif
  void set_model_version(const char* value);
  void set_model_version(const char* value, size_t size);
  ::std::string* mutable_model_version();
  ::std::string* release_model_version();
  void set_allocated_model_version(::std::string* model_version);

  // string method = 2;
  void clear_method();
  static const int kMethodFieldNumber = 2;
  const ::std::string& method() const;
  void set_method(const ::std::string& value);
  #if LANG_CXX11
  void set_method(::std::string&& value);
  #endif
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  ::std::string* mutable_method();
  ::std::string* release_method();
  void set_allocated_method(::std::string* method);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceFeatureVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr model_version_;
  ::google::protobuf::internal::ArenaStringPtr method_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5freply_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceTokenReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceTokenReply) */ {
 public:
  FaceTokenReply();
  virtual ~FaceTokenReply();

  FaceTokenReply(const FaceTokenReply& from);

  inline FaceTokenReply& operator=(const FaceTokenReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceTokenReply(FaceTokenReply&& from) noexcept
    : FaceTokenReply() {
    *this = ::std::move(from);
  }

  inline FaceTokenReply& operator=(FaceTokenReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceTokenReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceTokenReply* internal_default_instance() {
    return reinterpret_cast<const FaceTokenReply*>(
               &_FaceTokenReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FaceTokenReply* other);
  friend void swap(FaceTokenReply& a, FaceTokenReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceTokenReply* New() const final {
    return CreateMaybeMessage<FaceTokenReply>(NULL);
  }

  FaceTokenReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceTokenReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceTokenReply& from);
  void MergeFrom(const FaceTokenReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceTokenReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes blob = 4;
  void clear_blob();
  static const int kBlobFieldNumber = 4;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // .sputnik.pb.FaceTokenReplyStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::sputnik::pb::FaceTokenReplyStatus status() const;
  void set_status(::sputnik::pb::FaceTokenReplyStatus value);

  // .sputnik.pb.FaceQuality face_quality = 2;
  void clear_face_quality();
  static const int kFaceQualityFieldNumber = 2;
  ::sputnik::pb::FaceQuality face_quality() const;
  void set_face_quality(::sputnik::pb::FaceQuality value);

  // int32 token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceTokenReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  int status_;
  int face_quality_;
  ::google::protobuf::int32 token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5freply_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceRecognitionReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceRecognitionReply) */ {
 public:
  FaceRecognitionReply();
  virtual ~FaceRecognitionReply();

  FaceRecognitionReply(const FaceRecognitionReply& from);

  inline FaceRecognitionReply& operator=(const FaceRecognitionReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceRecognitionReply(FaceRecognitionReply&& from) noexcept
    : FaceRecognitionReply() {
    *this = ::std::move(from);
  }

  inline FaceRecognitionReply& operator=(FaceRecognitionReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceRecognitionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceRecognitionReply* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionReply*>(
               &_FaceRecognitionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FaceRecognitionReply* other);
  friend void swap(FaceRecognitionReply& a, FaceRecognitionReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceRecognitionReply* New() const final {
    return CreateMaybeMessage<FaceRecognitionReply>(NULL);
  }

  FaceRecognitionReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceRecognitionReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceRecognitionReply& from);
  void MergeFrom(const FaceRecognitionReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecognitionReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sputnik.pb.TokenScore scores = 2;
  int scores_size() const;
  void clear_scores();
  static const int kScoresFieldNumber = 2;
  ::sputnik::pb::TokenScore* mutable_scores(int index);
  ::google::protobuf::RepeatedPtrField< ::sputnik::pb::TokenScore >*
      mutable_scores();
  const ::sputnik::pb::TokenScore& scores(int index) const;
  ::sputnik::pb::TokenScore* add_scores();
  const ::google::protobuf::RepeatedPtrField< ::sputnik::pb::TokenScore >&
      scores() const;

  // .sputnik.pb.FaceTokenReply token_reply = 1;
  bool has_token_reply() const;
  void clear_token_reply();
  static const int kTokenReplyFieldNumber = 1;
  private:
  const ::sputnik::pb::FaceTokenReply& _internal_token_reply() const;
  public:
  const ::sputnik::pb::FaceTokenReply& token_reply() const;
  ::sputnik::pb::FaceTokenReply* release_token_reply();
  ::sputnik::pb::FaceTokenReply* mutable_token_reply();
  void set_allocated_token_reply(::sputnik::pb::FaceTokenReply* token_reply);

  // .sputnik.pb.FaceFeatureVersion feature_version = 3;
  bool has_feature_version() const;
  void clear_feature_version();
  static const int kFeatureVersionFieldNumber = 3;
  private:
  const ::sputnik::pb::FaceFeatureVersion& _internal_feature_version() const;
  public:
  const ::sputnik::pb::FaceFeatureVersion& feature_version() const;
  ::sputnik::pb::FaceFeatureVersion* release_feature_version();
  ::sputnik::pb::FaceFeatureVersion* mutable_feature_version();
  void set_allocated_feature_version(::sputnik::pb::FaceFeatureVersion* feature_version);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceRecognitionReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sputnik::pb::TokenScore > scores_;
  ::sputnik::pb::FaceTokenReply* token_reply_;
  ::sputnik::pb::FaceFeatureVersion* feature_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5freply_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceReply) */ {
 public:
  FaceReply();
  virtual ~FaceReply();

  FaceReply(const FaceReply& from);

  inline FaceReply& operator=(const FaceReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceReply(FaceReply&& from) noexcept
    : FaceReply() {
    *this = ::std::move(from);
  }

  inline FaceReply& operator=(FaceReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceReply* internal_default_instance() {
    return reinterpret_cast<const FaceReply*>(
               &_FaceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FaceReply* other);
  friend void swap(FaceReply& a, FaceReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceReply* New() const final {
    return CreateMaybeMessage<FaceReply>(NULL);
  }

  FaceReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceReply& from);
  void MergeFrom(const FaceReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sputnik.pb.FaceAttributeReply face_attribute_reply = 1;
  bool has_face_attribute_reply() const;
  void clear_face_attribute_reply();
  static const int kFaceAttributeReplyFieldNumber = 1;
  private:
  const ::sputnik::pb::FaceAttributeReply& _internal_face_attribute_reply() const;
  public:
  const ::sputnik::pb::FaceAttributeReply& face_attribute_reply() const;
  ::sputnik::pb::FaceAttributeReply* release_face_attribute_reply();
  ::sputnik::pb::FaceAttributeReply* mutable_face_attribute_reply();
  void set_allocated_face_attribute_reply(::sputnik::pb::FaceAttributeReply* face_attribute_reply);

  // .sputnik.pb.FaceRecognitionReply face_recognition_reply = 2;
  bool has_face_recognition_reply() const;
  void clear_face_recognition_reply();
  static const int kFaceRecognitionReplyFieldNumber = 2;
  private:
  const ::sputnik::pb::FaceRecognitionReply& _internal_face_recognition_reply() const;
  public:
  const ::sputnik::pb::FaceRecognitionReply& face_recognition_reply() const;
  ::sputnik::pb::FaceRecognitionReply* release_face_recognition_reply();
  ::sputnik::pb::FaceRecognitionReply* mutable_face_recognition_reply();
  void set_allocated_face_recognition_reply(::sputnik::pb::FaceRecognitionReply* face_recognition_reply);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sputnik::pb::FaceAttributeReply* face_attribute_reply_;
  ::sputnik::pb::FaceRecognitionReply* face_recognition_reply_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5freply_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TokenScore

// int32 token = 1;
inline void TokenScore::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 TokenScore::token() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.TokenScore.token)
  return token_;
}
inline void TokenScore::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.TokenScore.token)
}

// double score = 2;
inline void TokenScore::clear_score() {
  score_ = 0;
}
inline double TokenScore::score() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.TokenScore.score)
  return score_;
}
inline void TokenScore::set_score(double value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.TokenScore.score)
}

// -------------------------------------------------------------------

// FaceAttributeReply

// .sputnik.pb.FaceAttributeReplyStatus status = 1;
inline void FaceAttributeReply::clear_status() {
  status_ = 0;
}
inline ::sputnik::pb::FaceAttributeReplyStatus FaceAttributeReply::status() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeReply.status)
  return static_cast< ::sputnik::pb::FaceAttributeReplyStatus >(status_);
}
inline void FaceAttributeReply::set_status(::sputnik::pb::FaceAttributeReplyStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceAttributeReply.status)
}

// .sputnik.pb.FaceAttribute attribute = 2;
inline bool FaceAttributeReply::has_attribute() const {
  return this != internal_default_instance() && attribute_ != NULL;
}
inline const ::sputnik::pb::FaceAttribute& FaceAttributeReply::_internal_attribute() const {
  return *attribute_;
}
inline const ::sputnik::pb::FaceAttribute& FaceAttributeReply::attribute() const {
  const ::sputnik::pb::FaceAttribute* p = attribute_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeReply.attribute)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceAttribute*>(
      &::sputnik::pb::_FaceAttribute_default_instance_);
}
inline ::sputnik::pb::FaceAttribute* FaceAttributeReply::release_attribute() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceAttributeReply.attribute)
  
  ::sputnik::pb::FaceAttribute* temp = attribute_;
  attribute_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceAttribute* FaceAttributeReply::mutable_attribute() {
  
  if (attribute_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceAttribute>(GetArenaNoVirtual());
    attribute_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceAttributeReply.attribute)
  return attribute_;
}
inline void FaceAttributeReply::set_allocated_attribute(::sputnik::pb::FaceAttribute* attribute) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(attribute_);
  }
  if (attribute) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attribute = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attribute, submessage_arena);
    }
    
  } else {
    
  }
  attribute_ = attribute;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceAttributeReply.attribute)
}

// -------------------------------------------------------------------

// FaceFeatureVersion

// string model_version = 1;
inline void FaceFeatureVersion::clear_model_version() {
  model_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaceFeatureVersion::model_version() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceFeatureVersion.model_version)
  return model_version_.GetNoArena();
}
inline void FaceFeatureVersion::set_model_version(const ::std::string& value) {
  
  model_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceFeatureVersion.model_version)
}
#if LANG_CXX11
inline void FaceFeatureVersion::set_model_version(::std::string&& value) {
  
  model_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceFeatureVersion.model_version)
}
#endif
inline void FaceFeatureVersion::set_model_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceFeatureVersion.model_version)
}
inline void FaceFeatureVersion::set_model_version(const char* value, size_t size) {
  
  model_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceFeatureVersion.model_version)
}
inline ::std::string* FaceFeatureVersion::mutable_model_version() {
  
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceFeatureVersion.model_version)
  return model_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceFeatureVersion::release_model_version() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceFeatureVersion.model_version)
  
  return model_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceFeatureVersion::set_allocated_model_version(::std::string* model_version) {
  if (model_version != NULL) {
    
  } else {
    
  }
  model_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_version);
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceFeatureVersion.model_version)
}

// string method = 2;
inline void FaceFeatureVersion::clear_method() {
  method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaceFeatureVersion::method() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceFeatureVersion.method)
  return method_.GetNoArena();
}
inline void FaceFeatureVersion::set_method(const ::std::string& value) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceFeatureVersion.method)
}
#if LANG_CXX11
inline void FaceFeatureVersion::set_method(::std::string&& value) {
  
  method_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceFeatureVersion.method)
}
#endif
inline void FaceFeatureVersion::set_method(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceFeatureVersion.method)
}
inline void FaceFeatureVersion::set_method(const char* value, size_t size) {
  
  method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceFeatureVersion.method)
}
inline ::std::string* FaceFeatureVersion::mutable_method() {
  
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceFeatureVersion.method)
  return method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceFeatureVersion::release_method() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceFeatureVersion.method)
  
  return method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceFeatureVersion::set_allocated_method(::std::string* method) {
  if (method != NULL) {
    
  } else {
    
  }
  method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method);
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceFeatureVersion.method)
}

// -------------------------------------------------------------------

// FaceTokenReply

// .sputnik.pb.FaceTokenReplyStatus status = 1;
inline void FaceTokenReply::clear_status() {
  status_ = 0;
}
inline ::sputnik::pb::FaceTokenReplyStatus FaceTokenReply::status() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenReply.status)
  return static_cast< ::sputnik::pb::FaceTokenReplyStatus >(status_);
}
inline void FaceTokenReply::set_status(::sputnik::pb::FaceTokenReplyStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenReply.status)
}

// .sputnik.pb.FaceQuality face_quality = 2;
inline void FaceTokenReply::clear_face_quality() {
  face_quality_ = 0;
}
inline ::sputnik::pb::FaceQuality FaceTokenReply::face_quality() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenReply.face_quality)
  return static_cast< ::sputnik::pb::FaceQuality >(face_quality_);
}
inline void FaceTokenReply::set_face_quality(::sputnik::pb::FaceQuality value) {
  
  face_quality_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenReply.face_quality)
}

// int32 token = 3;
inline void FaceTokenReply::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 FaceTokenReply::token() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenReply.token)
  return token_;
}
inline void FaceTokenReply::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenReply.token)
}

// bytes blob = 4;
inline void FaceTokenReply::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaceTokenReply::blob() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenReply.blob)
  return blob_.GetNoArena();
}
inline void FaceTokenReply::set_blob(const ::std::string& value) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenReply.blob)
}
#if LANG_CXX11
inline void FaceTokenReply::set_blob(::std::string&& value) {
  
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceTokenReply.blob)
}
#endif
inline void FaceTokenReply::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceTokenReply.blob)
}
inline void FaceTokenReply::set_blob(const void* value, size_t size) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceTokenReply.blob)
}
inline ::std::string* FaceTokenReply::mutable_blob() {
  
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceTokenReply.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceTokenReply::release_blob() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceTokenReply.blob)
  
  return blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceTokenReply::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    
  } else {
    
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceTokenReply.blob)
}

// -------------------------------------------------------------------

// FaceRecognitionReply

// .sputnik.pb.FaceTokenReply token_reply = 1;
inline bool FaceRecognitionReply::has_token_reply() const {
  return this != internal_default_instance() && token_reply_ != NULL;
}
inline void FaceRecognitionReply::clear_token_reply() {
  if (GetArenaNoVirtual() == NULL && token_reply_ != NULL) {
    delete token_reply_;
  }
  token_reply_ = NULL;
}
inline const ::sputnik::pb::FaceTokenReply& FaceRecognitionReply::_internal_token_reply() const {
  return *token_reply_;
}
inline const ::sputnik::pb::FaceTokenReply& FaceRecognitionReply::token_reply() const {
  const ::sputnik::pb::FaceTokenReply* p = token_reply_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecognitionReply.token_reply)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceTokenReply*>(
      &::sputnik::pb::_FaceTokenReply_default_instance_);
}
inline ::sputnik::pb::FaceTokenReply* FaceRecognitionReply::release_token_reply() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRecognitionReply.token_reply)
  
  ::sputnik::pb::FaceTokenReply* temp = token_reply_;
  token_reply_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceTokenReply* FaceRecognitionReply::mutable_token_reply() {
  
  if (token_reply_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceTokenReply>(GetArenaNoVirtual());
    token_reply_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRecognitionReply.token_reply)
  return token_reply_;
}
inline void FaceRecognitionReply::set_allocated_token_reply(::sputnik::pb::FaceTokenReply* token_reply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete token_reply_;
  }
  if (token_reply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      token_reply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, token_reply, submessage_arena);
    }
    
  } else {
    
  }
  token_reply_ = token_reply;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRecognitionReply.token_reply)
}

// repeated .sputnik.pb.TokenScore scores = 2;
inline int FaceRecognitionReply::scores_size() const {
  return scores_.size();
}
inline void FaceRecognitionReply::clear_scores() {
  scores_.Clear();
}
inline ::sputnik::pb::TokenScore* FaceRecognitionReply::mutable_scores(int index) {
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRecognitionReply.scores)
  return scores_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sputnik::pb::TokenScore >*
FaceRecognitionReply::mutable_scores() {
  // @@protoc_insertion_point(field_mutable_list:sputnik.pb.FaceRecognitionReply.scores)
  return &scores_;
}
inline const ::sputnik::pb::TokenScore& FaceRecognitionReply::scores(int index) const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecognitionReply.scores)
  return scores_.Get(index);
}
inline ::sputnik::pb::TokenScore* FaceRecognitionReply::add_scores() {
  // @@protoc_insertion_point(field_add:sputnik.pb.FaceRecognitionReply.scores)
  return scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sputnik::pb::TokenScore >&
FaceRecognitionReply::scores() const {
  // @@protoc_insertion_point(field_list:sputnik.pb.FaceRecognitionReply.scores)
  return scores_;
}

// .sputnik.pb.FaceFeatureVersion feature_version = 3;
inline bool FaceRecognitionReply::has_feature_version() const {
  return this != internal_default_instance() && feature_version_ != NULL;
}
inline void FaceRecognitionReply::clear_feature_version() {
  if (GetArenaNoVirtual() == NULL && feature_version_ != NULL) {
    delete feature_version_;
  }
  feature_version_ = NULL;
}
inline const ::sputnik::pb::FaceFeatureVersion& FaceRecognitionReply::_internal_feature_version() const {
  return *feature_version_;
}
inline const ::sputnik::pb::FaceFeatureVersion& FaceRecognitionReply::feature_version() const {
  const ::sputnik::pb::FaceFeatureVersion* p = feature_version_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecognitionReply.feature_version)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceFeatureVersion*>(
      &::sputnik::pb::_FaceFeatureVersion_default_instance_);
}
inline ::sputnik::pb::FaceFeatureVersion* FaceRecognitionReply::release_feature_version() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRecognitionReply.feature_version)
  
  ::sputnik::pb::FaceFeatureVersion* temp = feature_version_;
  feature_version_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceFeatureVersion* FaceRecognitionReply::mutable_feature_version() {
  
  if (feature_version_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceFeatureVersion>(GetArenaNoVirtual());
    feature_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRecognitionReply.feature_version)
  return feature_version_;
}
inline void FaceRecognitionReply::set_allocated_feature_version(::sputnik::pb::FaceFeatureVersion* feature_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_version_;
  }
  if (feature_version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_version, submessage_arena);
    }
    
  } else {
    
  }
  feature_version_ = feature_version;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRecognitionReply.feature_version)
}

// -------------------------------------------------------------------

// FaceReply

// .sputnik.pb.FaceAttributeReply face_attribute_reply = 1;
inline bool FaceReply::has_face_attribute_reply() const {
  return this != internal_default_instance() && face_attribute_reply_ != NULL;
}
inline void FaceReply::clear_face_attribute_reply() {
  if (GetArenaNoVirtual() == NULL && face_attribute_reply_ != NULL) {
    delete face_attribute_reply_;
  }
  face_attribute_reply_ = NULL;
}
inline const ::sputnik::pb::FaceAttributeReply& FaceReply::_internal_face_attribute_reply() const {
  return *face_attribute_reply_;
}
inline const ::sputnik::pb::FaceAttributeReply& FaceReply::face_attribute_reply() const {
  const ::sputnik::pb::FaceAttributeReply* p = face_attribute_reply_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceReply.face_attribute_reply)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceAttributeReply*>(
      &::sputnik::pb::_FaceAttributeReply_default_instance_);
}
inline ::sputnik::pb::FaceAttributeReply* FaceReply::release_face_attribute_reply() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceReply.face_attribute_reply)
  
  ::sputnik::pb::FaceAttributeReply* temp = face_attribute_reply_;
  face_attribute_reply_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceAttributeReply* FaceReply::mutable_face_attribute_reply() {
  
  if (face_attribute_reply_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceAttributeReply>(GetArenaNoVirtual());
    face_attribute_reply_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceReply.face_attribute_reply)
  return face_attribute_reply_;
}
inline void FaceReply::set_allocated_face_attribute_reply(::sputnik::pb::FaceAttributeReply* face_attribute_reply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete face_attribute_reply_;
  }
  if (face_attribute_reply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      face_attribute_reply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, face_attribute_reply, submessage_arena);
    }
    
  } else {
    
  }
  face_attribute_reply_ = face_attribute_reply;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceReply.face_attribute_reply)
}

// .sputnik.pb.FaceRecognitionReply face_recognition_reply = 2;
inline bool FaceReply::has_face_recognition_reply() const {
  return this != internal_default_instance() && face_recognition_reply_ != NULL;
}
inline void FaceReply::clear_face_recognition_reply() {
  if (GetArenaNoVirtual() == NULL && face_recognition_reply_ != NULL) {
    delete face_recognition_reply_;
  }
  face_recognition_reply_ = NULL;
}
inline const ::sputnik::pb::FaceRecognitionReply& FaceReply::_internal_face_recognition_reply() const {
  return *face_recognition_reply_;
}
inline const ::sputnik::pb::FaceRecognitionReply& FaceReply::face_recognition_reply() const {
  const ::sputnik::pb::FaceRecognitionReply* p = face_recognition_reply_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceReply.face_recognition_reply)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceRecognitionReply*>(
      &::sputnik::pb::_FaceRecognitionReply_default_instance_);
}
inline ::sputnik::pb::FaceRecognitionReply* FaceReply::release_face_recognition_reply() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceReply.face_recognition_reply)
  
  ::sputnik::pb::FaceRecognitionReply* temp = face_recognition_reply_;
  face_recognition_reply_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceRecognitionReply* FaceReply::mutable_face_recognition_reply() {
  
  if (face_recognition_reply_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceRecognitionReply>(GetArenaNoVirtual());
    face_recognition_reply_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceReply.face_recognition_reply)
  return face_recognition_reply_;
}
inline void FaceReply::set_allocated_face_recognition_reply(::sputnik::pb::FaceRecognitionReply* face_recognition_reply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete face_recognition_reply_;
  }
  if (face_recognition_reply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      face_recognition_reply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, face_recognition_reply, submessage_arena);
    }
    
  } else {
    
  }
  face_recognition_reply_ = face_recognition_reply;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceReply.face_recognition_reply)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace sputnik

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sputnik::pb::FaceAttributeReplyStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sputnik::pb::FaceAttributeReplyStatus>() {
  return ::sputnik::pb::FaceAttributeReplyStatus_descriptor();
}
template <> struct is_proto_enum< ::sputnik::pb::FaceQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sputnik::pb::FaceQuality>() {
  return ::sputnik::pb::FaceQuality_descriptor();
}
template <> struct is_proto_enum< ::sputnik::pb::FaceTokenReplyStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sputnik::pb::FaceTokenReplyStatus>() {
  return ::sputnik::pb::FaceTokenReplyStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_face_5freply_2eproto
