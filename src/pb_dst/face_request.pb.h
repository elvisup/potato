// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: face_request.proto

#ifndef PROTOBUF_INCLUDED_face_5frequest_2eproto
#define PROTOBUF_INCLUDED_face_5frequest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "image.pb.h"
#include "box.pb.h"
#include "face_attribute.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_face_5frequest_2eproto 

namespace protobuf_face_5frequest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_face_5frequest_2eproto
namespace sputnik {
namespace pb {
class FaceAttributeRequest;
class FaceAttributeRequestDefaultTypeInternal;
extern FaceAttributeRequestDefaultTypeInternal _FaceAttributeRequest_default_instance_;
class FaceBlurRequirement;
class FaceBlurRequirementDefaultTypeInternal;
extern FaceBlurRequirementDefaultTypeInternal _FaceBlurRequirement_default_instance_;
class FacePoseRequirement;
class FacePoseRequirementDefaultTypeInternal;
extern FacePoseRequirementDefaultTypeInternal _FacePoseRequirement_default_instance_;
class FaceRecognitionRequest;
class FaceRecognitionRequestDefaultTypeInternal;
extern FaceRecognitionRequestDefaultTypeInternal _FaceRecognitionRequest_default_instance_;
class FaceRequest;
class FaceRequestDefaultTypeInternal;
extern FaceRequestDefaultTypeInternal _FaceRequest_default_instance_;
class FaceTokenRequest;
class FaceTokenRequestDefaultTypeInternal;
extern FaceTokenRequestDefaultTypeInternal _FaceTokenRequest_default_instance_;
}  // namespace pb
}  // namespace sputnik
namespace google {
namespace protobuf {
template<> ::sputnik::pb::FaceAttributeRequest* Arena::CreateMaybeMessage<::sputnik::pb::FaceAttributeRequest>(Arena*);
template<> ::sputnik::pb::FaceBlurRequirement* Arena::CreateMaybeMessage<::sputnik::pb::FaceBlurRequirement>(Arena*);
template<> ::sputnik::pb::FacePoseRequirement* Arena::CreateMaybeMessage<::sputnik::pb::FacePoseRequirement>(Arena*);
template<> ::sputnik::pb::FaceRecognitionRequest* Arena::CreateMaybeMessage<::sputnik::pb::FaceRecognitionRequest>(Arena*);
template<> ::sputnik::pb::FaceRequest* Arena::CreateMaybeMessage<::sputnik::pb::FaceRequest>(Arena*);
template<> ::sputnik::pb::FaceTokenRequest* Arena::CreateMaybeMessage<::sputnik::pb::FaceTokenRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sputnik {
namespace pb {

// ===================================================================

class FaceAttributeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceAttributeRequest) */ {
 public:
  FaceAttributeRequest();
  virtual ~FaceAttributeRequest();

  FaceAttributeRequest(const FaceAttributeRequest& from);

  inline FaceAttributeRequest& operator=(const FaceAttributeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceAttributeRequest(FaceAttributeRequest&& from) noexcept
    : FaceAttributeRequest() {
    *this = ::std::move(from);
  }

  inline FaceAttributeRequest& operator=(FaceAttributeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceAttributeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceAttributeRequest* internal_default_instance() {
    return reinterpret_cast<const FaceAttributeRequest*>(
               &_FaceAttributeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FaceAttributeRequest* other);
  friend void swap(FaceAttributeRequest& a, FaceAttributeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceAttributeRequest* New() const final {
    return CreateMaybeMessage<FaceAttributeRequest>(NULL);
  }

  FaceAttributeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceAttributeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceAttributeRequest& from);
  void MergeFrom(const FaceAttributeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceAttributeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool predict_blur = 1;
  void clear_predict_blur();
  static const int kPredictBlurFieldNumber = 1;
  bool predict_blur() const;
  void set_predict_blur(bool value);

  // bool predict_age_gender = 2;
  void clear_predict_age_gender();
  static const int kPredictAgeGenderFieldNumber = 2;
  bool predict_age_gender() const;
  void set_predict_age_gender(bool value);

  // bool predict_pose = 3;
  void clear_predict_pose();
  static const int kPredictPoseFieldNumber = 3;
  bool predict_pose() const;
  void set_predict_pose(bool value);

  // bool predict_landmark = 4;
  void clear_predict_landmark();
  static const int kPredictLandmarkFieldNumber = 4;
  bool predict_landmark() const;
  void set_predict_landmark(bool value);

  // bool predict_postfilter = 5;
  void clear_predict_postfilter();
  static const int kPredictPostfilterFieldNumber = 5;
  bool predict_postfilter() const;
  void set_predict_postfilter(bool value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceAttributeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool predict_blur_;
  bool predict_age_gender_;
  bool predict_pose_;
  bool predict_landmark_;
  bool predict_postfilter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FacePoseRequirement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FacePoseRequirement) */ {
 public:
  FacePoseRequirement();
  virtual ~FacePoseRequirement();

  FacePoseRequirement(const FacePoseRequirement& from);

  inline FacePoseRequirement& operator=(const FacePoseRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FacePoseRequirement(FacePoseRequirement&& from) noexcept
    : FacePoseRequirement() {
    *this = ::std::move(from);
  }

  inline FacePoseRequirement& operator=(FacePoseRequirement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FacePoseRequirement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FacePoseRequirement* internal_default_instance() {
    return reinterpret_cast<const FacePoseRequirement*>(
               &_FacePoseRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FacePoseRequirement* other);
  friend void swap(FacePoseRequirement& a, FacePoseRequirement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FacePoseRequirement* New() const final {
    return CreateMaybeMessage<FacePoseRequirement>(NULL);
  }

  FacePoseRequirement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FacePoseRequirement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FacePoseRequirement& from);
  void MergeFrom(const FacePoseRequirement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FacePoseRequirement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 min_pitch_deg = 1;
  void clear_min_pitch_deg();
  static const int kMinPitchDegFieldNumber = 1;
  ::google::protobuf::int32 min_pitch_deg() const;
  void set_min_pitch_deg(::google::protobuf::int32 value);

  // int32 max_pitch_deg = 2;
  void clear_max_pitch_deg();
  static const int kMaxPitchDegFieldNumber = 2;
  ::google::protobuf::int32 max_pitch_deg() const;
  void set_max_pitch_deg(::google::protobuf::int32 value);

  // int32 min_yaw_deg = 3;
  void clear_min_yaw_deg();
  static const int kMinYawDegFieldNumber = 3;
  ::google::protobuf::int32 min_yaw_deg() const;
  void set_min_yaw_deg(::google::protobuf::int32 value);

  // int32 max_yaw_deg = 4;
  void clear_max_yaw_deg();
  static const int kMaxYawDegFieldNumber = 4;
  ::google::protobuf::int32 max_yaw_deg() const;
  void set_max_yaw_deg(::google::protobuf::int32 value);

  // int32 min_roll_deg = 5;
  void clear_min_roll_deg();
  static const int kMinRollDegFieldNumber = 5;
  ::google::protobuf::int32 min_roll_deg() const;
  void set_min_roll_deg(::google::protobuf::int32 value);

  // int32 max_roll_deg = 6;
  void clear_max_roll_deg();
  static const int kMaxRollDegFieldNumber = 6;
  ::google::protobuf::int32 max_roll_deg() const;
  void set_max_roll_deg(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FacePoseRequirement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 min_pitch_deg_;
  ::google::protobuf::int32 max_pitch_deg_;
  ::google::protobuf::int32 min_yaw_deg_;
  ::google::protobuf::int32 max_yaw_deg_;
  ::google::protobuf::int32 min_roll_deg_;
  ::google::protobuf::int32 max_roll_deg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceBlurRequirement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceBlurRequirement) */ {
 public:
  FaceBlurRequirement();
  virtual ~FaceBlurRequirement();

  FaceBlurRequirement(const FaceBlurRequirement& from);

  inline FaceBlurRequirement& operator=(const FaceBlurRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceBlurRequirement(FaceBlurRequirement&& from) noexcept
    : FaceBlurRequirement() {
    *this = ::std::move(from);
  }

  inline FaceBlurRequirement& operator=(FaceBlurRequirement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceBlurRequirement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceBlurRequirement* internal_default_instance() {
    return reinterpret_cast<const FaceBlurRequirement*>(
               &_FaceBlurRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FaceBlurRequirement* other);
  friend void swap(FaceBlurRequirement& a, FaceBlurRequirement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceBlurRequirement* New() const final {
    return CreateMaybeMessage<FaceBlurRequirement>(NULL);
  }

  FaceBlurRequirement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceBlurRequirement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceBlurRequirement& from);
  void MergeFrom(const FaceBlurRequirement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceBlurRequirement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 max_blur = 1;
  void clear_max_blur();
  static const int kMaxBlurFieldNumber = 1;
  ::google::protobuf::int32 max_blur() const;
  void set_max_blur(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceBlurRequirement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 max_blur_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceTokenRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceTokenRequest) */ {
 public:
  FaceTokenRequest();
  virtual ~FaceTokenRequest();

  FaceTokenRequest(const FaceTokenRequest& from);

  inline FaceTokenRequest& operator=(const FaceTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceTokenRequest(FaceTokenRequest&& from) noexcept
    : FaceTokenRequest() {
    *this = ::std::move(from);
  }

  inline FaceTokenRequest& operator=(FaceTokenRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceTokenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceTokenRequest* internal_default_instance() {
    return reinterpret_cast<const FaceTokenRequest*>(
               &_FaceTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FaceTokenRequest* other);
  friend void swap(FaceTokenRequest& a, FaceTokenRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceTokenRequest* New() const final {
    return CreateMaybeMessage<FaceTokenRequest>(NULL);
  }

  FaceTokenRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceTokenRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceTokenRequest& from);
  void MergeFrom(const FaceTokenRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceTokenRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string model = 2;
  void clear_model();
  static const int kModelFieldNumber = 2;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // string strategy = 3;
  void clear_strategy();
  static const int kStrategyFieldNumber = 3;
  const ::std::string& strategy() const;
  void set_strategy(const ::std::string& value);
  #if LANG_CXX11
  void set_strategy(::std::string&& value);
  #endif
  void set_strategy(const char* value);
  void set_strategy(const char* value, size_t size);
  ::std::string* mutable_strategy();
  ::std::string* release_strategy();
  void set_allocated_strategy(::std::string* strategy);

  // .sputnik.pb.FacePoseRequirement pose_requirement = 6;
  bool has_pose_requirement() const;
  void clear_pose_requirement();
  static const int kPoseRequirementFieldNumber = 6;
  private:
  const ::sputnik::pb::FacePoseRequirement& _internal_pose_requirement() const;
  public:
  const ::sputnik::pb::FacePoseRequirement& pose_requirement() const;
  ::sputnik::pb::FacePoseRequirement* release_pose_requirement();
  ::sputnik::pb::FacePoseRequirement* mutable_pose_requirement();
  void set_allocated_pose_requirement(::sputnik::pb::FacePoseRequirement* pose_requirement);

  // .sputnik.pb.FaceBlurRequirement blur_requirement = 7;
  bool has_blur_requirement() const;
  void clear_blur_requirement();
  static const int kBlurRequirementFieldNumber = 7;
  private:
  const ::sputnik::pb::FaceBlurRequirement& _internal_blur_requirement() const;
  public:
  const ::sputnik::pb::FaceBlurRequirement& blur_requirement() const;
  ::sputnik::pb::FaceBlurRequirement* release_blur_requirement();
  ::sputnik::pb::FaceBlurRequirement* mutable_blur_requirement();
  void set_allocated_blur_requirement(::sputnik::pb::FaceBlurRequirement* blur_requirement);

  // bool add_new_token = 1;
  void clear_add_new_token();
  static const int kAddNewTokenFieldNumber = 1;
  bool add_new_token() const;
  void set_add_new_token(bool value);

  // bool already_aligned = 4;
  void clear_already_aligned();
  static const int kAlreadyAlignedFieldNumber = 4;
  bool already_aligned() const;
  void set_already_aligned(bool value);

  // int32 min_face_pixels = 5;
  void clear_min_face_pixels();
  static const int kMinFacePixelsFieldNumber = 5;
  ::google::protobuf::int32 min_face_pixels() const;
  void set_min_face_pixels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceTokenRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::google::protobuf::internal::ArenaStringPtr strategy_;
  ::sputnik::pb::FacePoseRequirement* pose_requirement_;
  ::sputnik::pb::FaceBlurRequirement* blur_requirement_;
  bool add_new_token_;
  bool already_aligned_;
  ::google::protobuf::int32 min_face_pixels_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceRecognitionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceRecognitionRequest) */ {
 public:
  FaceRecognitionRequest();
  virtual ~FaceRecognitionRequest();

  FaceRecognitionRequest(const FaceRecognitionRequest& from);

  inline FaceRecognitionRequest& operator=(const FaceRecognitionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceRecognitionRequest(FaceRecognitionRequest&& from) noexcept
    : FaceRecognitionRequest() {
    *this = ::std::move(from);
  }

  inline FaceRecognitionRequest& operator=(FaceRecognitionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceRecognitionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceRecognitionRequest* internal_default_instance() {
    return reinterpret_cast<const FaceRecognitionRequest*>(
               &_FaceRecognitionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FaceRecognitionRequest* other);
  friend void swap(FaceRecognitionRequest& a, FaceRecognitionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceRecognitionRequest* New() const final {
    return CreateMaybeMessage<FaceRecognitionRequest>(NULL);
  }

  FaceRecognitionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceRecognitionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceRecognitionRequest& from);
  void MergeFrom(const FaceRecognitionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecognitionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sputnik.pb.FaceTokenRequest token_request = 3;
  bool has_token_request() const;
  void clear_token_request();
  static const int kTokenRequestFieldNumber = 3;
  private:
  const ::sputnik::pb::FaceTokenRequest& _internal_token_request() const;
  public:
  const ::sputnik::pb::FaceTokenRequest& token_request() const;
  ::sputnik::pb::FaceTokenRequest* release_token_request();
  ::sputnik::pb::FaceTokenRequest* mutable_token_request();
  void set_allocated_token_request(::sputnik::pb::FaceTokenRequest* token_request);

  // int32 max_num_scores = 1;
  void clear_max_num_scores();
  static const int kMaxNumScoresFieldNumber = 1;
  ::google::protobuf::int32 max_num_scores() const;
  void set_max_num_scores(::google::protobuf::int32 value);

  // int32 precision = 2;
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceRecognitionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sputnik::pb::FaceTokenRequest* token_request_;
  ::google::protobuf::int32 max_num_scores_;
  ::google::protobuf::int32 precision_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceRequest) */ {
 public:
  FaceRequest();
  virtual ~FaceRequest();

  FaceRequest(const FaceRequest& from);

  inline FaceRequest& operator=(const FaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceRequest(FaceRequest&& from) noexcept
    : FaceRequest() {
    *this = ::std::move(from);
  }

  inline FaceRequest& operator=(FaceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceRequest& default_instance();

  enum ImageCase {
    kRawImage = 1,
    kEncodedImage = 2,
    IMAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceRequest* internal_default_instance() {
    return reinterpret_cast<const FaceRequest*>(
               &_FaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FaceRequest* other);
  friend void swap(FaceRequest& a, FaceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceRequest* New() const final {
    return CreateMaybeMessage<FaceRequest>(NULL);
  }

  FaceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceRequest& from);
  void MergeFrom(const FaceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sputnik.pb.Box box_in_image = 3;
  bool has_box_in_image() const;
  void clear_box_in_image();
  static const int kBoxInImageFieldNumber = 3;
  private:
  const ::sputnik::pb::Box& _internal_box_in_image() const;
  public:
  const ::sputnik::pb::Box& box_in_image() const;
  ::sputnik::pb::Box* release_box_in_image();
  ::sputnik::pb::Box* mutable_box_in_image();
  void set_allocated_box_in_image(::sputnik::pb::Box* box_in_image);

  // .sputnik.pb.FaceLandMark landmark = 4;
  bool has_landmark() const;
  void clear_landmark();
  static const int kLandmarkFieldNumber = 4;
  private:
  const ::sputnik::pb::FaceLandMark& _internal_landmark() const;
  public:
  const ::sputnik::pb::FaceLandMark& landmark() const;
  ::sputnik::pb::FaceLandMark* release_landmark();
  ::sputnik::pb::FaceLandMark* mutable_landmark();
  void set_allocated_landmark(::sputnik::pb::FaceLandMark* landmark);

  // .sputnik.pb.FaceAttributeRequest attribute_request = 5;
  bool has_attribute_request() const;
  void clear_attribute_request();
  static const int kAttributeRequestFieldNumber = 5;
  private:
  const ::sputnik::pb::FaceAttributeRequest& _internal_attribute_request() const;
  public:
  const ::sputnik::pb::FaceAttributeRequest& attribute_request() const;
  ::sputnik::pb::FaceAttributeRequest* release_attribute_request();
  ::sputnik::pb::FaceAttributeRequest* mutable_attribute_request();
  void set_allocated_attribute_request(::sputnik::pb::FaceAttributeRequest* attribute_request);

  // .sputnik.pb.FaceRecognitionRequest recognition_request = 6;
  bool has_recognition_request() const;
  void clear_recognition_request();
  static const int kRecognitionRequestFieldNumber = 6;
  private:
  const ::sputnik::pb::FaceRecognitionRequest& _internal_recognition_request() const;
  public:
  const ::sputnik::pb::FaceRecognitionRequest& recognition_request() const;
  ::sputnik::pb::FaceRecognitionRequest* release_recognition_request();
  ::sputnik::pb::FaceRecognitionRequest* mutable_recognition_request();
  void set_allocated_recognition_request(::sputnik::pb::FaceRecognitionRequest* recognition_request);

  // int32 priority = 8;
  void clear_priority();
  static const int kPriorityFieldNumber = 8;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // .sputnik.pb.Image raw_image = 1;
  bool has_raw_image() const;
  void clear_raw_image();
  static const int kRawImageFieldNumber = 1;
  private:
  const ::sputnik::pb::Image& _internal_raw_image() const;
  public:
  const ::sputnik::pb::Image& raw_image() const;
  ::sputnik::pb::Image* release_raw_image();
  ::sputnik::pb::Image* mutable_raw_image();
  void set_allocated_raw_image(::sputnik::pb::Image* raw_image);

  // .sputnik.pb.EncodedImage encoded_image = 2;
  bool has_encoded_image() const;
  void clear_encoded_image();
  static const int kEncodedImageFieldNumber = 2;
  private:
  const ::sputnik::pb::EncodedImage& _internal_encoded_image() const;
  public:
  const ::sputnik::pb::EncodedImage& encoded_image() const;
  ::sputnik::pb::EncodedImage* release_encoded_image();
  ::sputnik::pb::EncodedImage* mutable_encoded_image();
  void set_allocated_encoded_image(::sputnik::pb::EncodedImage* encoded_image);

  void clear_image();
  ImageCase image_case() const;
  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceRequest)
 private:
  void set_has_raw_image();
  void set_has_encoded_image();

  inline bool has_image() const;
  inline void clear_has_image();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sputnik::pb::Box* box_in_image_;
  ::sputnik::pb::FaceLandMark* landmark_;
  ::sputnik::pb::FaceAttributeRequest* attribute_request_;
  ::sputnik::pb::FaceRecognitionRequest* recognition_request_;
  ::google::protobuf::int32 priority_;
  union ImageUnion {
    ImageUnion() {}
    ::sputnik::pb::Image* raw_image_;
    ::sputnik::pb::EncodedImage* encoded_image_;
  } image_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_face_5frequest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FaceAttributeRequest

// bool predict_blur = 1;
inline void FaceAttributeRequest::clear_predict_blur() {
  predict_blur_ = false;
}
inline bool FaceAttributeRequest::predict_blur() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeRequest.predict_blur)
  return predict_blur_;
}
inline void FaceAttributeRequest::set_predict_blur(bool value) {
  
  predict_blur_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceAttributeRequest.predict_blur)
}

// bool predict_age_gender = 2;
inline void FaceAttributeRequest::clear_predict_age_gender() {
  predict_age_gender_ = false;
}
inline bool FaceAttributeRequest::predict_age_gender() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeRequest.predict_age_gender)
  return predict_age_gender_;
}
inline void FaceAttributeRequest::set_predict_age_gender(bool value) {
  
  predict_age_gender_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceAttributeRequest.predict_age_gender)
}

// bool predict_pose = 3;
inline void FaceAttributeRequest::clear_predict_pose() {
  predict_pose_ = false;
}
inline bool FaceAttributeRequest::predict_pose() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeRequest.predict_pose)
  return predict_pose_;
}
inline void FaceAttributeRequest::set_predict_pose(bool value) {
  
  predict_pose_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceAttributeRequest.predict_pose)
}

// bool predict_landmark = 4;
inline void FaceAttributeRequest::clear_predict_landmark() {
  predict_landmark_ = false;
}
inline bool FaceAttributeRequest::predict_landmark() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeRequest.predict_landmark)
  return predict_landmark_;
}
inline void FaceAttributeRequest::set_predict_landmark(bool value) {
  
  predict_landmark_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceAttributeRequest.predict_landmark)
}

// bool predict_postfilter = 5;
inline void FaceAttributeRequest::clear_predict_postfilter() {
  predict_postfilter_ = false;
}
inline bool FaceAttributeRequest::predict_postfilter() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceAttributeRequest.predict_postfilter)
  return predict_postfilter_;
}
inline void FaceAttributeRequest::set_predict_postfilter(bool value) {
  
  predict_postfilter_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceAttributeRequest.predict_postfilter)
}

// -------------------------------------------------------------------

// FacePoseRequirement

// int32 min_pitch_deg = 1;
inline void FacePoseRequirement::clear_min_pitch_deg() {
  min_pitch_deg_ = 0;
}
inline ::google::protobuf::int32 FacePoseRequirement::min_pitch_deg() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FacePoseRequirement.min_pitch_deg)
  return min_pitch_deg_;
}
inline void FacePoseRequirement::set_min_pitch_deg(::google::protobuf::int32 value) {
  
  min_pitch_deg_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FacePoseRequirement.min_pitch_deg)
}

// int32 max_pitch_deg = 2;
inline void FacePoseRequirement::clear_max_pitch_deg() {
  max_pitch_deg_ = 0;
}
inline ::google::protobuf::int32 FacePoseRequirement::max_pitch_deg() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FacePoseRequirement.max_pitch_deg)
  return max_pitch_deg_;
}
inline void FacePoseRequirement::set_max_pitch_deg(::google::protobuf::int32 value) {
  
  max_pitch_deg_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FacePoseRequirement.max_pitch_deg)
}

// int32 min_yaw_deg = 3;
inline void FacePoseRequirement::clear_min_yaw_deg() {
  min_yaw_deg_ = 0;
}
inline ::google::protobuf::int32 FacePoseRequirement::min_yaw_deg() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FacePoseRequirement.min_yaw_deg)
  return min_yaw_deg_;
}
inline void FacePoseRequirement::set_min_yaw_deg(::google::protobuf::int32 value) {
  
  min_yaw_deg_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FacePoseRequirement.min_yaw_deg)
}

// int32 max_yaw_deg = 4;
inline void FacePoseRequirement::clear_max_yaw_deg() {
  max_yaw_deg_ = 0;
}
inline ::google::protobuf::int32 FacePoseRequirement::max_yaw_deg() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FacePoseRequirement.max_yaw_deg)
  return max_yaw_deg_;
}
inline void FacePoseRequirement::set_max_yaw_deg(::google::protobuf::int32 value) {
  
  max_yaw_deg_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FacePoseRequirement.max_yaw_deg)
}

// int32 min_roll_deg = 5;
inline void FacePoseRequirement::clear_min_roll_deg() {
  min_roll_deg_ = 0;
}
inline ::google::protobuf::int32 FacePoseRequirement::min_roll_deg() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FacePoseRequirement.min_roll_deg)
  return min_roll_deg_;
}
inline void FacePoseRequirement::set_min_roll_deg(::google::protobuf::int32 value) {
  
  min_roll_deg_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FacePoseRequirement.min_roll_deg)
}

// int32 max_roll_deg = 6;
inline void FacePoseRequirement::clear_max_roll_deg() {
  max_roll_deg_ = 0;
}
inline ::google::protobuf::int32 FacePoseRequirement::max_roll_deg() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FacePoseRequirement.max_roll_deg)
  return max_roll_deg_;
}
inline void FacePoseRequirement::set_max_roll_deg(::google::protobuf::int32 value) {
  
  max_roll_deg_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FacePoseRequirement.max_roll_deg)
}

// -------------------------------------------------------------------

// FaceBlurRequirement

// int32 max_blur = 1;
inline void FaceBlurRequirement::clear_max_blur() {
  max_blur_ = 0;
}
inline ::google::protobuf::int32 FaceBlurRequirement::max_blur() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceBlurRequirement.max_blur)
  return max_blur_;
}
inline void FaceBlurRequirement::set_max_blur(::google::protobuf::int32 value) {
  
  max_blur_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceBlurRequirement.max_blur)
}

// -------------------------------------------------------------------

// FaceTokenRequest

// bool add_new_token = 1;
inline void FaceTokenRequest::clear_add_new_token() {
  add_new_token_ = false;
}
inline bool FaceTokenRequest::add_new_token() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.add_new_token)
  return add_new_token_;
}
inline void FaceTokenRequest::set_add_new_token(bool value) {
  
  add_new_token_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenRequest.add_new_token)
}

// string model = 2;
inline void FaceTokenRequest::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaceTokenRequest::model() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.model)
  return model_.GetNoArena();
}
inline void FaceTokenRequest::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenRequest.model)
}
#if LANG_CXX11
inline void FaceTokenRequest::set_model(::std::string&& value) {
  
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceTokenRequest.model)
}
#endif
inline void FaceTokenRequest::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceTokenRequest.model)
}
inline void FaceTokenRequest::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceTokenRequest.model)
}
inline ::std::string* FaceTokenRequest::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceTokenRequest.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceTokenRequest::release_model() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceTokenRequest.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceTokenRequest::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceTokenRequest.model)
}

// string strategy = 3;
inline void FaceTokenRequest::clear_strategy() {
  strategy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaceTokenRequest::strategy() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.strategy)
  return strategy_.GetNoArena();
}
inline void FaceTokenRequest::set_strategy(const ::std::string& value) {
  
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenRequest.strategy)
}
#if LANG_CXX11
inline void FaceTokenRequest::set_strategy(::std::string&& value) {
  
  strategy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceTokenRequest.strategy)
}
#endif
inline void FaceTokenRequest::set_strategy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceTokenRequest.strategy)
}
inline void FaceTokenRequest::set_strategy(const char* value, size_t size) {
  
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceTokenRequest.strategy)
}
inline ::std::string* FaceTokenRequest::mutable_strategy() {
  
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceTokenRequest.strategy)
  return strategy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceTokenRequest::release_strategy() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceTokenRequest.strategy)
  
  return strategy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceTokenRequest::set_allocated_strategy(::std::string* strategy) {
  if (strategy != NULL) {
    
  } else {
    
  }
  strategy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strategy);
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceTokenRequest.strategy)
}

// bool already_aligned = 4;
inline void FaceTokenRequest::clear_already_aligned() {
  already_aligned_ = false;
}
inline bool FaceTokenRequest::already_aligned() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.already_aligned)
  return already_aligned_;
}
inline void FaceTokenRequest::set_already_aligned(bool value) {
  
  already_aligned_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenRequest.already_aligned)
}

// int32 min_face_pixels = 5;
inline void FaceTokenRequest::clear_min_face_pixels() {
  min_face_pixels_ = 0;
}
inline ::google::protobuf::int32 FaceTokenRequest::min_face_pixels() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.min_face_pixels)
  return min_face_pixels_;
}
inline void FaceTokenRequest::set_min_face_pixels(::google::protobuf::int32 value) {
  
  min_face_pixels_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceTokenRequest.min_face_pixels)
}

// .sputnik.pb.FacePoseRequirement pose_requirement = 6;
inline bool FaceTokenRequest::has_pose_requirement() const {
  return this != internal_default_instance() && pose_requirement_ != NULL;
}
inline void FaceTokenRequest::clear_pose_requirement() {
  if (GetArenaNoVirtual() == NULL && pose_requirement_ != NULL) {
    delete pose_requirement_;
  }
  pose_requirement_ = NULL;
}
inline const ::sputnik::pb::FacePoseRequirement& FaceTokenRequest::_internal_pose_requirement() const {
  return *pose_requirement_;
}
inline const ::sputnik::pb::FacePoseRequirement& FaceTokenRequest::pose_requirement() const {
  const ::sputnik::pb::FacePoseRequirement* p = pose_requirement_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.pose_requirement)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FacePoseRequirement*>(
      &::sputnik::pb::_FacePoseRequirement_default_instance_);
}
inline ::sputnik::pb::FacePoseRequirement* FaceTokenRequest::release_pose_requirement() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceTokenRequest.pose_requirement)
  
  ::sputnik::pb::FacePoseRequirement* temp = pose_requirement_;
  pose_requirement_ = NULL;
  return temp;
}
inline ::sputnik::pb::FacePoseRequirement* FaceTokenRequest::mutable_pose_requirement() {
  
  if (pose_requirement_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FacePoseRequirement>(GetArenaNoVirtual());
    pose_requirement_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceTokenRequest.pose_requirement)
  return pose_requirement_;
}
inline void FaceTokenRequest::set_allocated_pose_requirement(::sputnik::pb::FacePoseRequirement* pose_requirement) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_requirement_;
  }
  if (pose_requirement) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose_requirement = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose_requirement, submessage_arena);
    }
    
  } else {
    
  }
  pose_requirement_ = pose_requirement;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceTokenRequest.pose_requirement)
}

// .sputnik.pb.FaceBlurRequirement blur_requirement = 7;
inline bool FaceTokenRequest::has_blur_requirement() const {
  return this != internal_default_instance() && blur_requirement_ != NULL;
}
inline void FaceTokenRequest::clear_blur_requirement() {
  if (GetArenaNoVirtual() == NULL && blur_requirement_ != NULL) {
    delete blur_requirement_;
  }
  blur_requirement_ = NULL;
}
inline const ::sputnik::pb::FaceBlurRequirement& FaceTokenRequest::_internal_blur_requirement() const {
  return *blur_requirement_;
}
inline const ::sputnik::pb::FaceBlurRequirement& FaceTokenRequest::blur_requirement() const {
  const ::sputnik::pb::FaceBlurRequirement* p = blur_requirement_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceTokenRequest.blur_requirement)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceBlurRequirement*>(
      &::sputnik::pb::_FaceBlurRequirement_default_instance_);
}
inline ::sputnik::pb::FaceBlurRequirement* FaceTokenRequest::release_blur_requirement() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceTokenRequest.blur_requirement)
  
  ::sputnik::pb::FaceBlurRequirement* temp = blur_requirement_;
  blur_requirement_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceBlurRequirement* FaceTokenRequest::mutable_blur_requirement() {
  
  if (blur_requirement_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceBlurRequirement>(GetArenaNoVirtual());
    blur_requirement_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceTokenRequest.blur_requirement)
  return blur_requirement_;
}
inline void FaceTokenRequest::set_allocated_blur_requirement(::sputnik::pb::FaceBlurRequirement* blur_requirement) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blur_requirement_;
  }
  if (blur_requirement) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blur_requirement = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blur_requirement, submessage_arena);
    }
    
  } else {
    
  }
  blur_requirement_ = blur_requirement;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceTokenRequest.blur_requirement)
}

// -------------------------------------------------------------------

// FaceRecognitionRequest

// int32 max_num_scores = 1;
inline void FaceRecognitionRequest::clear_max_num_scores() {
  max_num_scores_ = 0;
}
inline ::google::protobuf::int32 FaceRecognitionRequest::max_num_scores() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecognitionRequest.max_num_scores)
  return max_num_scores_;
}
inline void FaceRecognitionRequest::set_max_num_scores(::google::protobuf::int32 value) {
  
  max_num_scores_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRecognitionRequest.max_num_scores)
}

// int32 precision = 2;
inline void FaceRecognitionRequest::clear_precision() {
  precision_ = 0;
}
inline ::google::protobuf::int32 FaceRecognitionRequest::precision() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecognitionRequest.precision)
  return precision_;
}
inline void FaceRecognitionRequest::set_precision(::google::protobuf::int32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRecognitionRequest.precision)
}

// .sputnik.pb.FaceTokenRequest token_request = 3;
inline bool FaceRecognitionRequest::has_token_request() const {
  return this != internal_default_instance() && token_request_ != NULL;
}
inline void FaceRecognitionRequest::clear_token_request() {
  if (GetArenaNoVirtual() == NULL && token_request_ != NULL) {
    delete token_request_;
  }
  token_request_ = NULL;
}
inline const ::sputnik::pb::FaceTokenRequest& FaceRecognitionRequest::_internal_token_request() const {
  return *token_request_;
}
inline const ::sputnik::pb::FaceTokenRequest& FaceRecognitionRequest::token_request() const {
  const ::sputnik::pb::FaceTokenRequest* p = token_request_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecognitionRequest.token_request)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceTokenRequest*>(
      &::sputnik::pb::_FaceTokenRequest_default_instance_);
}
inline ::sputnik::pb::FaceTokenRequest* FaceRecognitionRequest::release_token_request() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRecognitionRequest.token_request)
  
  ::sputnik::pb::FaceTokenRequest* temp = token_request_;
  token_request_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceTokenRequest* FaceRecognitionRequest::mutable_token_request() {
  
  if (token_request_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceTokenRequest>(GetArenaNoVirtual());
    token_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRecognitionRequest.token_request)
  return token_request_;
}
inline void FaceRecognitionRequest::set_allocated_token_request(::sputnik::pb::FaceTokenRequest* token_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete token_request_;
  }
  if (token_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      token_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, token_request, submessage_arena);
    }
    
  } else {
    
  }
  token_request_ = token_request;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRecognitionRequest.token_request)
}

// -------------------------------------------------------------------

// FaceRequest

// .sputnik.pb.Image raw_image = 1;
inline bool FaceRequest::has_raw_image() const {
  return image_case() == kRawImage;
}
inline void FaceRequest::set_has_raw_image() {
  _oneof_case_[0] = kRawImage;
}
inline const ::sputnik::pb::Image& FaceRequest::_internal_raw_image() const {
  return *image_.raw_image_;
}
inline ::sputnik::pb::Image* FaceRequest::release_raw_image() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRequest.raw_image)
  if (has_raw_image()) {
    clear_has_image();
      ::sputnik::pb::Image* temp = image_.raw_image_;
    image_.raw_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sputnik::pb::Image& FaceRequest::raw_image() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.raw_image)
  return has_raw_image()
      ? *image_.raw_image_
      : *reinterpret_cast< ::sputnik::pb::Image*>(&::sputnik::pb::_Image_default_instance_);
}
inline ::sputnik::pb::Image* FaceRequest::mutable_raw_image() {
  if (!has_raw_image()) {
    clear_image();
    set_has_raw_image();
    image_.raw_image_ = CreateMaybeMessage< ::sputnik::pb::Image >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRequest.raw_image)
  return image_.raw_image_;
}

// .sputnik.pb.EncodedImage encoded_image = 2;
inline bool FaceRequest::has_encoded_image() const {
  return image_case() == kEncodedImage;
}
inline void FaceRequest::set_has_encoded_image() {
  _oneof_case_[0] = kEncodedImage;
}
inline const ::sputnik::pb::EncodedImage& FaceRequest::_internal_encoded_image() const {
  return *image_.encoded_image_;
}
inline ::sputnik::pb::EncodedImage* FaceRequest::release_encoded_image() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRequest.encoded_image)
  if (has_encoded_image()) {
    clear_has_image();
      ::sputnik::pb::EncodedImage* temp = image_.encoded_image_;
    image_.encoded_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sputnik::pb::EncodedImage& FaceRequest::encoded_image() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.encoded_image)
  return has_encoded_image()
      ? *image_.encoded_image_
      : *reinterpret_cast< ::sputnik::pb::EncodedImage*>(&::sputnik::pb::_EncodedImage_default_instance_);
}
inline ::sputnik::pb::EncodedImage* FaceRequest::mutable_encoded_image() {
  if (!has_encoded_image()) {
    clear_image();
    set_has_encoded_image();
    image_.encoded_image_ = CreateMaybeMessage< ::sputnik::pb::EncodedImage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRequest.encoded_image)
  return image_.encoded_image_;
}

// .sputnik.pb.Box box_in_image = 3;
inline bool FaceRequest::has_box_in_image() const {
  return this != internal_default_instance() && box_in_image_ != NULL;
}
inline const ::sputnik::pb::Box& FaceRequest::_internal_box_in_image() const {
  return *box_in_image_;
}
inline const ::sputnik::pb::Box& FaceRequest::box_in_image() const {
  const ::sputnik::pb::Box* p = box_in_image_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.box_in_image)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::Box*>(
      &::sputnik::pb::_Box_default_instance_);
}
inline ::sputnik::pb::Box* FaceRequest::release_box_in_image() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRequest.box_in_image)
  
  ::sputnik::pb::Box* temp = box_in_image_;
  box_in_image_ = NULL;
  return temp;
}
inline ::sputnik::pb::Box* FaceRequest::mutable_box_in_image() {
  
  if (box_in_image_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::Box>(GetArenaNoVirtual());
    box_in_image_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRequest.box_in_image)
  return box_in_image_;
}
inline void FaceRequest::set_allocated_box_in_image(::sputnik::pb::Box* box_in_image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(box_in_image_);
  }
  if (box_in_image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      box_in_image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, box_in_image, submessage_arena);
    }
    
  } else {
    
  }
  box_in_image_ = box_in_image;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRequest.box_in_image)
}

// .sputnik.pb.FaceLandMark landmark = 4;
inline bool FaceRequest::has_landmark() const {
  return this != internal_default_instance() && landmark_ != NULL;
}
inline const ::sputnik::pb::FaceLandMark& FaceRequest::_internal_landmark() const {
  return *landmark_;
}
inline const ::sputnik::pb::FaceLandMark& FaceRequest::landmark() const {
  const ::sputnik::pb::FaceLandMark* p = landmark_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.landmark)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceLandMark*>(
      &::sputnik::pb::_FaceLandMark_default_instance_);
}
inline ::sputnik::pb::FaceLandMark* FaceRequest::release_landmark() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRequest.landmark)
  
  ::sputnik::pb::FaceLandMark* temp = landmark_;
  landmark_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceLandMark* FaceRequest::mutable_landmark() {
  
  if (landmark_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceLandMark>(GetArenaNoVirtual());
    landmark_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRequest.landmark)
  return landmark_;
}
inline void FaceRequest::set_allocated_landmark(::sputnik::pb::FaceLandMark* landmark) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(landmark_);
  }
  if (landmark) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      landmark = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, landmark, submessage_arena);
    }
    
  } else {
    
  }
  landmark_ = landmark;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRequest.landmark)
}

// .sputnik.pb.FaceAttributeRequest attribute_request = 5;
inline bool FaceRequest::has_attribute_request() const {
  return this != internal_default_instance() && attribute_request_ != NULL;
}
inline void FaceRequest::clear_attribute_request() {
  if (GetArenaNoVirtual() == NULL && attribute_request_ != NULL) {
    delete attribute_request_;
  }
  attribute_request_ = NULL;
}
inline const ::sputnik::pb::FaceAttributeRequest& FaceRequest::_internal_attribute_request() const {
  return *attribute_request_;
}
inline const ::sputnik::pb::FaceAttributeRequest& FaceRequest::attribute_request() const {
  const ::sputnik::pb::FaceAttributeRequest* p = attribute_request_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.attribute_request)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceAttributeRequest*>(
      &::sputnik::pb::_FaceAttributeRequest_default_instance_);
}
inline ::sputnik::pb::FaceAttributeRequest* FaceRequest::release_attribute_request() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRequest.attribute_request)
  
  ::sputnik::pb::FaceAttributeRequest* temp = attribute_request_;
  attribute_request_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceAttributeRequest* FaceRequest::mutable_attribute_request() {
  
  if (attribute_request_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceAttributeRequest>(GetArenaNoVirtual());
    attribute_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRequest.attribute_request)
  return attribute_request_;
}
inline void FaceRequest::set_allocated_attribute_request(::sputnik::pb::FaceAttributeRequest* attribute_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attribute_request_;
  }
  if (attribute_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attribute_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attribute_request, submessage_arena);
    }
    
  } else {
    
  }
  attribute_request_ = attribute_request;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRequest.attribute_request)
}

// .sputnik.pb.FaceRecognitionRequest recognition_request = 6;
inline bool FaceRequest::has_recognition_request() const {
  return this != internal_default_instance() && recognition_request_ != NULL;
}
inline void FaceRequest::clear_recognition_request() {
  if (GetArenaNoVirtual() == NULL && recognition_request_ != NULL) {
    delete recognition_request_;
  }
  recognition_request_ = NULL;
}
inline const ::sputnik::pb::FaceRecognitionRequest& FaceRequest::_internal_recognition_request() const {
  return *recognition_request_;
}
inline const ::sputnik::pb::FaceRecognitionRequest& FaceRequest::recognition_request() const {
  const ::sputnik::pb::FaceRecognitionRequest* p = recognition_request_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.recognition_request)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceRecognitionRequest*>(
      &::sputnik::pb::_FaceRecognitionRequest_default_instance_);
}
inline ::sputnik::pb::FaceRecognitionRequest* FaceRequest::release_recognition_request() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRequest.recognition_request)
  
  ::sputnik::pb::FaceRecognitionRequest* temp = recognition_request_;
  recognition_request_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceRecognitionRequest* FaceRequest::mutable_recognition_request() {
  
  if (recognition_request_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceRecognitionRequest>(GetArenaNoVirtual());
    recognition_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRequest.recognition_request)
  return recognition_request_;
}
inline void FaceRequest::set_allocated_recognition_request(::sputnik::pb::FaceRecognitionRequest* recognition_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete recognition_request_;
  }
  if (recognition_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      recognition_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, recognition_request, submessage_arena);
    }
    
  } else {
    
  }
  recognition_request_ = recognition_request;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRequest.recognition_request)
}

// int32 priority = 8;
inline void FaceRequest::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 FaceRequest::priority() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRequest.priority)
  return priority_;
}
inline void FaceRequest::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRequest.priority)
}

inline bool FaceRequest::has_image() const {
  return image_case() != IMAGE_NOT_SET;
}
inline void FaceRequest::clear_has_image() {
  _oneof_case_[0] = IMAGE_NOT_SET;
}
inline FaceRequest::ImageCase FaceRequest::image_case() const {
  return FaceRequest::ImageCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace sputnik

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_face_5frequest_2eproto
