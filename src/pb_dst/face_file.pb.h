// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: face_file.proto

#ifndef PROTOBUF_INCLUDED_face_5ffile_2eproto
#define PROTOBUF_INCLUDED_face_5ffile_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "face_reply.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_face_5ffile_2eproto 

namespace protobuf_face_5ffile_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_face_5ffile_2eproto
namespace sputnik {
namespace pb {
class FaceFile;
class FaceFileDefaultTypeInternal;
extern FaceFileDefaultTypeInternal _FaceFile_default_instance_;
class FaceLibrary;
class FaceLibraryDefaultTypeInternal;
extern FaceLibraryDefaultTypeInternal _FaceLibrary_default_instance_;
class FaceRecord;
class FaceRecordDefaultTypeInternal;
extern FaceRecordDefaultTypeInternal _FaceRecord_default_instance_;
}  // namespace pb
}  // namespace sputnik
namespace google {
namespace protobuf {
template<> ::sputnik::pb::FaceFile* Arena::CreateMaybeMessage<::sputnik::pb::FaceFile>(Arena*);
template<> ::sputnik::pb::FaceLibrary* Arena::CreateMaybeMessage<::sputnik::pb::FaceLibrary>(Arena*);
template<> ::sputnik::pb::FaceRecord* Arena::CreateMaybeMessage<::sputnik::pb::FaceRecord>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sputnik {
namespace pb {

// ===================================================================

class FaceRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceRecord) */ {
 public:
  FaceRecord();
  virtual ~FaceRecord();

  FaceRecord(const FaceRecord& from);

  inline FaceRecord& operator=(const FaceRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceRecord(FaceRecord&& from) noexcept
    : FaceRecord() {
    *this = ::std::move(from);
  }

  inline FaceRecord& operator=(FaceRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceRecord* internal_default_instance() {
    return reinterpret_cast<const FaceRecord*>(
               &_FaceRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FaceRecord* other);
  friend void swap(FaceRecord& a, FaceRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceRecord* New() const final {
    return CreateMaybeMessage<FaceRecord>(NULL);
  }

  FaceRecord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceRecord>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceRecord& from);
  void MergeFrom(const FaceRecord& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes blob = 3;
  void clear_blob();
  static const int kBlobFieldNumber = 3;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // .sputnik.pb.FaceFeatureVersion feature_version = 4;
  bool has_feature_version() const;
  void clear_feature_version();
  static const int kFeatureVersionFieldNumber = 4;
  private:
  const ::sputnik::pb::FaceFeatureVersion& _internal_feature_version() const;
  public:
  const ::sputnik::pb::FaceFeatureVersion& feature_version() const;
  ::sputnik::pb::FaceFeatureVersion* release_feature_version();
  ::sputnik::pb::FaceFeatureVersion* mutable_feature_version();
  void set_allocated_feature_version(::sputnik::pb::FaceFeatureVersion* feature_version);

  // int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // bool activation = 2;
  void clear_activation();
  static const int kActivationFieldNumber = 2;
  bool activation() const;
  void set_activation(bool value);

  // uint64 checksum = 5;
  void clear_checksum();
  static const int kChecksumFieldNumber = 5;
  ::google::protobuf::uint64 checksum() const;
  void set_checksum(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  ::sputnik::pb::FaceFeatureVersion* feature_version_;
  ::google::protobuf::int32 token_;
  bool activation_;
  ::google::protobuf::uint64 checksum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5ffile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceLibrary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceLibrary) */ {
 public:
  FaceLibrary();
  virtual ~FaceLibrary();

  FaceLibrary(const FaceLibrary& from);

  inline FaceLibrary& operator=(const FaceLibrary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceLibrary(FaceLibrary&& from) noexcept
    : FaceLibrary() {
    *this = ::std::move(from);
  }

  inline FaceLibrary& operator=(FaceLibrary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceLibrary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceLibrary* internal_default_instance() {
    return reinterpret_cast<const FaceLibrary*>(
               &_FaceLibrary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FaceLibrary* other);
  friend void swap(FaceLibrary& a, FaceLibrary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceLibrary* New() const final {
    return CreateMaybeMessage<FaceLibrary>(NULL);
  }

  FaceLibrary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceLibrary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceLibrary& from);
  void MergeFrom(const FaceLibrary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceLibrary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sputnik.pb.FaceRecord records = 1;
  int records_size() const;
  void clear_records();
  static const int kRecordsFieldNumber = 1;
  ::sputnik::pb::FaceRecord* mutable_records(int index);
  ::google::protobuf::RepeatedPtrField< ::sputnik::pb::FaceRecord >*
      mutable_records();
  const ::sputnik::pb::FaceRecord& records(int index) const;
  ::sputnik::pb::FaceRecord* add_records();
  const ::google::protobuf::RepeatedPtrField< ::sputnik::pb::FaceRecord >&
      records() const;

  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceLibrary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sputnik::pb::FaceRecord > records_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_face_5ffile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sputnik.pb.FaceFile) */ {
 public:
  FaceFile();
  virtual ~FaceFile();

  FaceFile(const FaceFile& from);

  inline FaceFile& operator=(const FaceFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceFile(FaceFile&& from) noexcept
    : FaceFile() {
    *this = ::std::move(from);
  }

  inline FaceFile& operator=(FaceFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceFile& default_instance();

  enum FileCase {
    kLibrary = 1,
    kModel = 2,
    FILE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceFile* internal_default_instance() {
    return reinterpret_cast<const FaceFile*>(
               &_FaceFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FaceFile* other);
  friend void swap(FaceFile& a, FaceFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceFile* New() const final {
    return CreateMaybeMessage<FaceFile>(NULL);
  }

  FaceFile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceFile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceFile& from);
  void MergeFrom(const FaceFile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 checksum = 3;
  void clear_checksum();
  static const int kChecksumFieldNumber = 3;
  ::google::protobuf::uint64 checksum() const;
  void set_checksum(::google::protobuf::uint64 value);

  // .sputnik.pb.FaceLibrary library = 1;
  bool has_library() const;
  void clear_library();
  static const int kLibraryFieldNumber = 1;
  private:
  const ::sputnik::pb::FaceLibrary& _internal_library() const;
  public:
  const ::sputnik::pb::FaceLibrary& library() const;
  ::sputnik::pb::FaceLibrary* release_library();
  ::sputnik::pb::FaceLibrary* mutable_library();
  void set_allocated_library(::sputnik::pb::FaceLibrary* library);

  // bytes model = 2;
  private:
  bool has_model() const;
  public:
  void clear_model();
  static const int kModelFieldNumber = 2;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const void* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  void clear_file();
  FileCase file_case() const;
  // @@protoc_insertion_point(class_scope:sputnik.pb.FaceFile)
 private:
  void set_has_library();
  void set_has_model();

  inline bool has_file() const;
  inline void clear_has_file();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 checksum_;
  union FileUnion {
    FileUnion() {}
    ::sputnik::pb::FaceLibrary* library_;
    ::google::protobuf::internal::ArenaStringPtr model_;
  } file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_face_5ffile_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FaceRecord

// int32 token = 1;
inline void FaceRecord::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 FaceRecord::token() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecord.token)
  return token_;
}
inline void FaceRecord::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRecord.token)
}

// bool activation = 2;
inline void FaceRecord::clear_activation() {
  activation_ = false;
}
inline bool FaceRecord::activation() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecord.activation)
  return activation_;
}
inline void FaceRecord::set_activation(bool value) {
  
  activation_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRecord.activation)
}

// bytes blob = 3;
inline void FaceRecord::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaceRecord::blob() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecord.blob)
  return blob_.GetNoArena();
}
inline void FaceRecord::set_blob(const ::std::string& value) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRecord.blob)
}
#if LANG_CXX11
inline void FaceRecord::set_blob(::std::string&& value) {
  
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceRecord.blob)
}
#endif
inline void FaceRecord::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceRecord.blob)
}
inline void FaceRecord::set_blob(const void* value, size_t size) {
  
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceRecord.blob)
}
inline ::std::string* FaceRecord::mutable_blob() {
  
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRecord.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceRecord::release_blob() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRecord.blob)
  
  return blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceRecord::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    
  } else {
    
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRecord.blob)
}

// .sputnik.pb.FaceFeatureVersion feature_version = 4;
inline bool FaceRecord::has_feature_version() const {
  return this != internal_default_instance() && feature_version_ != NULL;
}
inline const ::sputnik::pb::FaceFeatureVersion& FaceRecord::_internal_feature_version() const {
  return *feature_version_;
}
inline const ::sputnik::pb::FaceFeatureVersion& FaceRecord::feature_version() const {
  const ::sputnik::pb::FaceFeatureVersion* p = feature_version_;
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecord.feature_version)
  return p != NULL ? *p : *reinterpret_cast<const ::sputnik::pb::FaceFeatureVersion*>(
      &::sputnik::pb::_FaceFeatureVersion_default_instance_);
}
inline ::sputnik::pb::FaceFeatureVersion* FaceRecord::release_feature_version() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceRecord.feature_version)
  
  ::sputnik::pb::FaceFeatureVersion* temp = feature_version_;
  feature_version_ = NULL;
  return temp;
}
inline ::sputnik::pb::FaceFeatureVersion* FaceRecord::mutable_feature_version() {
  
  if (feature_version_ == NULL) {
    auto* p = CreateMaybeMessage<::sputnik::pb::FaceFeatureVersion>(GetArenaNoVirtual());
    feature_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceRecord.feature_version)
  return feature_version_;
}
inline void FaceRecord::set_allocated_feature_version(::sputnik::pb::FaceFeatureVersion* feature_version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(feature_version_);
  }
  if (feature_version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_version, submessage_arena);
    }
    
  } else {
    
  }
  feature_version_ = feature_version;
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceRecord.feature_version)
}

// uint64 checksum = 5;
inline void FaceRecord::clear_checksum() {
  checksum_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FaceRecord::checksum() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceRecord.checksum)
  return checksum_;
}
inline void FaceRecord::set_checksum(::google::protobuf::uint64 value) {
  
  checksum_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceRecord.checksum)
}

// -------------------------------------------------------------------

// FaceLibrary

// repeated .sputnik.pb.FaceRecord records = 1;
inline int FaceLibrary::records_size() const {
  return records_.size();
}
inline void FaceLibrary::clear_records() {
  records_.Clear();
}
inline ::sputnik::pb::FaceRecord* FaceLibrary::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceLibrary.records)
  return records_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sputnik::pb::FaceRecord >*
FaceLibrary::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:sputnik.pb.FaceLibrary.records)
  return &records_;
}
inline const ::sputnik::pb::FaceRecord& FaceLibrary::records(int index) const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceLibrary.records)
  return records_.Get(index);
}
inline ::sputnik::pb::FaceRecord* FaceLibrary::add_records() {
  // @@protoc_insertion_point(field_add:sputnik.pb.FaceLibrary.records)
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sputnik::pb::FaceRecord >&
FaceLibrary::records() const {
  // @@protoc_insertion_point(field_list:sputnik.pb.FaceLibrary.records)
  return records_;
}

// -------------------------------------------------------------------

// FaceFile

// .sputnik.pb.FaceLibrary library = 1;
inline bool FaceFile::has_library() const {
  return file_case() == kLibrary;
}
inline void FaceFile::set_has_library() {
  _oneof_case_[0] = kLibrary;
}
inline void FaceFile::clear_library() {
  if (has_library()) {
    delete file_.library_;
    clear_has_file();
  }
}
inline const ::sputnik::pb::FaceLibrary& FaceFile::_internal_library() const {
  return *file_.library_;
}
inline ::sputnik::pb::FaceLibrary* FaceFile::release_library() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceFile.library)
  if (has_library()) {
    clear_has_file();
      ::sputnik::pb::FaceLibrary* temp = file_.library_;
    file_.library_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sputnik::pb::FaceLibrary& FaceFile::library() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceFile.library)
  return has_library()
      ? *file_.library_
      : *reinterpret_cast< ::sputnik::pb::FaceLibrary*>(&::sputnik::pb::_FaceLibrary_default_instance_);
}
inline ::sputnik::pb::FaceLibrary* FaceFile::mutable_library() {
  if (!has_library()) {
    clear_file();
    set_has_library();
    file_.library_ = CreateMaybeMessage< ::sputnik::pb::FaceLibrary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceFile.library)
  return file_.library_;
}

// bytes model = 2;
inline bool FaceFile::has_model() const {
  return file_case() == kModel;
}
inline void FaceFile::set_has_model() {
  _oneof_case_[0] = kModel;
}
inline void FaceFile::clear_model() {
  if (has_model()) {
    file_.model_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_file();
  }
}
inline const ::std::string& FaceFile::model() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceFile.model)
  if (has_model()) {
    return file_.model_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void FaceFile::set_model(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceFile.model)
  if (!has_model()) {
    clear_file();
    set_has_model();
    file_.model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  file_.model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceFile.model)
}
#if LANG_CXX11
inline void FaceFile::set_model(::std::string&& value) {
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceFile.model)
  if (!has_model()) {
    clear_file();
    set_has_model();
    file_.model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  file_.model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sputnik.pb.FaceFile.model)
}
#endif
inline void FaceFile::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_model()) {
    clear_file();
    set_has_model();
    file_.model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  file_.model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sputnik.pb.FaceFile.model)
}
inline void FaceFile::set_model(const void* value, size_t size) {
  if (!has_model()) {
    clear_file();
    set_has_model();
    file_.model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  file_.model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sputnik.pb.FaceFile.model)
}
inline ::std::string* FaceFile::mutable_model() {
  if (!has_model()) {
    clear_file();
    set_has_model();
    file_.model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:sputnik.pb.FaceFile.model)
  return file_.model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceFile::release_model() {
  // @@protoc_insertion_point(field_release:sputnik.pb.FaceFile.model)
  if (has_model()) {
    clear_has_file();
    return file_.model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void FaceFile::set_allocated_model(::std::string* model) {
  if (!has_model()) {
    file_.model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_file();
  if (model != NULL) {
    set_has_model();
    file_.model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  }
  // @@protoc_insertion_point(field_set_allocated:sputnik.pb.FaceFile.model)
}

// uint64 checksum = 3;
inline void FaceFile::clear_checksum() {
  checksum_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FaceFile::checksum() const {
  // @@protoc_insertion_point(field_get:sputnik.pb.FaceFile.checksum)
  return checksum_;
}
inline void FaceFile::set_checksum(::google::protobuf::uint64 value) {
  
  checksum_ = value;
  // @@protoc_insertion_point(field_set:sputnik.pb.FaceFile.checksum)
}

inline bool FaceFile::has_file() const {
  return file_case() != FILE_NOT_SET;
}
inline void FaceFile::clear_has_file() {
  _oneof_case_[0] = FILE_NOT_SET;
}
inline FaceFile::FileCase FaceFile::file_case() const {
  return FaceFile::FileCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace sputnik

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_face_5ffile_2eproto
